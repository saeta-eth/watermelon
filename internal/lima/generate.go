package lima

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/saeta/watermelon/internal/config"
)

// shellMetacharacters contains characters that could be used for shell injection
const shellMetacharacters = ";|&$`\\"

// validateDomain checks that a domain string doesn't contain shell metacharacters
func validateDomain(domain string) error {
	if domain == "" {
		return fmt.Errorf("domain cannot be empty")
	}
	if strings.ContainsAny(domain, shellMetacharacters) {
		return fmt.Errorf("domain %q contains invalid characters", domain)
	}
	return nil
}

// validatePort checks that a port is within the valid range 1-65535
func validatePort(port int) error {
	if port < 1 || port > 65535 {
		return fmt.Errorf("port %d is out of valid range (1-65535)", port)
	}
	return nil
}

const limaTemplate = `# Auto-generated by watermelon - do not edit
vmType: vz
arch: default
cpus: {{ .CPUs }}
memory: {{ .Memory }}
disk: {{ .Disk }}

images:
  - location: "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64.img"
    arch: aarch64
  - location: "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-amd64.img"
    arch: x86_64

mounts:
  - location: "{{ .ProjectDir }}"
    mountPoint: /project
    writable: true
{{- if .ToolsDir }}
  - location: "{{ .ToolsDir }}"
    mountPoint: /tools
    writable: false
{{- end }}

provision:
  - mode: system
    script: |
      set -e
      export DEBIAN_FRONTEND=noninteractive
{{- if .Tools }}
      # Create wrapper scripts for containerized tools
{{- range $image, $cmds := .Tools }}
{{- range $cmd := $cmds }}
      printf '%s\n' '#!/bin/bash' 'if [ -t 0 ]; then' '    exec nerdctl run --rm -it --network=host -v /project:/project -w /project {{ $image }} {{ $cmd }} "$@"' 'else' '    exec nerdctl run --rm --network=host -v /project:/project -w /project {{ $image }} {{ $cmd }} "$@"' 'fi' > /usr/local/bin/{{ $cmd }}
      chmod +x /usr/local/bin/{{ $cmd }}
{{- end }}
{{- end }}
{{- end }}
      # Network restrictions via iptables
{{- range .NetworkAllow }}
      iptables -A OUTPUT -d {{ . }} -j ACCEPT
{{- end }}
{{- if .NetworkAllow }}
      iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
      iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
      iptables -A OUTPUT -o lo -j ACCEPT
      iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
      iptables -A OUTPUT -j REJECT
{{- end }}

networks: []

portForwards:
{{- range .PortForwards }}
  - guestPort: {{ . }}
    hostPort: {{ . }}
{{- end }}
  # Disable automatic port forwarding for security isolation
  - ignore: true
    guestIP: "0.0.0.0"
    guestPortRange: [1, 65535]
  - ignore: true
    guestIP: "127.0.0.1"
    guestPortRange: [1, 65535]
`

type templateData struct {
	CPUs         int
	Memory       string
	Disk         string
	ProjectDir   string
	ToolsDir     string
	NetworkAllow []string
	PortForwards []int
	Tools        map[string][]string
}

// GenerateConfig creates Lima YAML from watermelon config
func GenerateConfig(cfg *config.Config, projectDir string) (string, error) {
	// Validate network allow domains
	for _, domain := range cfg.Network.Allow {
		if err := validateDomain(domain); err != nil {
			return "", fmt.Errorf("invalid network allow domain: %w", err)
		}
	}

	// Validate port forwards
	for _, port := range cfg.Ports.Forward {
		if err := validatePort(port); err != nil {
			return "", fmt.Errorf("invalid port forward: %w", err)
		}
	}

	tmpl, err := template.New("lima").Parse(limaTemplate)
	if err != nil {
		return "", fmt.Errorf("parsing template: %w", err)
	}

	data := templateData{
		CPUs:         cfg.Resources.CPUs,
		Memory:       convertMemory(cfg.Resources.Memory),
		Disk:         convertDisk(cfg.Resources.Disk),
		ProjectDir:   projectDir,
		ToolsDir:     "",
		NetworkAllow: cfg.Network.Allow,
		PortForwards: cfg.Ports.Forward,
		Tools:        cfg.Tools,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	return buf.String(), nil
}

// convertMemory converts "4GB" to "4GiB" for Lima
func convertMemory(mem string) string {
	return strings.Replace(mem, "GB", "GiB", 1)
}

// convertDisk converts "20GB" to "20GiB" for Lima
func convertDisk(disk string) string {
	return strings.Replace(disk, "GB", "GiB", 1)
}
